# -*- mode: shell-script -*-
#!/bin/sh

# Help message
function help() {
    printf "Usage: octopus  [OPTIONS]\n"
    printf "Usage: octopus  [OPTIONS] [info_port] [pub_port] [sub_port]\n"
    printf "Run a distributed test (Mesenger) of OpenDDS\n"
    printf ""
    printf "Options:\n"
    printf "\t-h,  --help\t\tShow this message\n"
    printf "\t-b,  --bootstrap\tBootstrap the whole platform (build Docker Linux container and Vagrant box from scratch)\n"
    printf "\t-d,  --destroy\t\tdestroy the platform and remove Docker Linux container and Vagrant box\n"
    printf "\t-r,  --run\t\tRun the tests\n"
    printf "\t-s,  --start\t\tStart the platform\n"
    printf "\t-t,  --terminate\tTerminate the platform\n"
    printf ""
    printf "Example:\n"
    printf "\toctopus --start 10000 1234 1234\t Start the platform (info_port=10000, pub_port=1234, sub_port=1234)\n"
    printf "\toctopus --start\t Start the platform with default ports\n"
    printf "\toctopus --run \t Run the test (after start the platform)\n" 
   printf "\toctopus -h\n"
}

# auxilary function
print_success() {
    printf "\t: done\n"
}

error() {
    echo "$@" 1>&2
}

fail() {
    error "$@" && exit 1
}

function rotate
{
    # usage:
    #   rotate &
    #   ROTATE_PID=$!
    #   your_task
    #   kill -9 $ROTATE_PID
    #  echo "\b\b  "
    INTERVAL=1
    RCOUNT="0"
    # Sleep time between rotation intervals
    while :
    do
	(( RCOUNT = RCOUNT + 1 ))
	# Increment the RCOUNT
	case $RCOUNT in
	    1) echo ’-’"\b\c"
		sleep $INTERVAL
		;;
	    2) echo ’\\’"\b\c"
		sleep $INTERVAL
		;;
	    3) echo "|\b\c"
		sleep $INTERVAL
		;;
	    4) echo "/\b\c"
		sleep $INTERVAL
		;;
	    *)
		RCOUNT="0"
		;;
	esac
    done
} # End of Function - rotate


# major functions
function bootstrap() {
    ./check
    sudo docker rmi docker_opendds 
    printf "build Docker image...\n"
    rotate &
    ROTATE_PID=$!
    # ./rebuild docker
    kill -9 $ROTATE_PID
    echo "\b\b  "
    print_success
    printf "build Vagrant box...\n"
    vagrant box remove dds
    # ./rebuild vagrant
    print_success

    # Let linux kernel forward the packet
    printf "enable Linux kernel forwarding packets..."
    forward=$(cat /proc/sys/net/ipv4/ip_forward)
    if [ $forward -eq 0 ]; then
	sudo 'echo 1 > /proc/sys/net/ipv4/ip_forward' 
	print_success
    else
	fail "cannot let Linux kernel forwarding packets..."
    fi

    printf "check virtual box bridge..."
    vboxnet=$(ip addr show vboxnet0 > /dev/null)
    if [ $vboxnet -ne 0 ] ; then
	vboxmanage hostonlyif create
	print_success
    fi
}

function destroy() {
    terminate
    printf "clean Docker image...\n"
#    sudo docker rmi docker_opendds 
    print_success
    printf "clean Vagrant box...\n"
#    vagrant destroy
    print_success
}

function run() {
    repo_port=$1
    pub_port=$2
    sub_port=$3
    printf "check port of inforepo...\t%u\n" "$repo_port"
    printf "check port of publisher...\t%u\n" "$pub_port"
    printf "check port of subscriber...\t%u\n" "$sub_port"
    echo "check ip of inforepo..."
    vnet=$(vboxmanage showvminfo repo_vm | grep "NIC.*Host-only" | gawk '{print $8}' | sed -e "s/'//g" -e "s/,//g")
    repo_gateway=$(ip addr show $vnet | grep -w inet | gawk '{print $2}' | sed 's/\/24//')
    repo_ip=$(echo $repo_gateway | gawk -F. '{print $1"."$2"."$3"."$4+1}')
    printf "\t%u\n" "$repo_ip"

    printf "run inforepo..."
    sed -e "s/repo_port/$repo_port/g" \
	-e "s/repo_ip/$repo_ip/g" \
	-e "s/repo_gateway/$repo_gateway/g" \
	./scripts/run_dds_win_template.bat > ./scripts/run_dds_win.bat ;
    vagrant provision &
    sleep 30
    print_success
    
    printf "run publisher..."
    docker run \
	-d --name pub -v "$PWD/scripts:/scripts" -w /scripts --env "repo_port=$repo_port" \
	--env "repo_ip=$repo_ip"  --env "host_port=$host_port" \
	-p $host_port \
	opendds_update \
	/scripts/publisher.sh
    sleep 5
    print_success
    
    printf  "run subscriber..."
    docker run \
	-d --name sub -v "$PWD/scripts:/scripts" -w /scripts --env "repo_port=$repo_port" \
	--env "repo_ip=$repo_ip" --env "host_port=$host_port" \
	-p $host_port \
	opendds_update \
	/scripts/subscriber.sh
    print_success
}

function terminate() {
    printf "terminate Virtualbox VM..."
#    vagrant halt;
    print_success
    printf "terminate Docker container..."
#    docker stop pub sub;
    print_success
}

function load() {
    printf "load Vagrant box..."
    vm_name=repo_vm
    sed -e "s/repo_port/$repo_port/g" \
	-e "s/vm_name/$vm_name/g" \
	Vagrant_template > Vagrantfile

    if ! vagrant status | grep repo_vm | grep -q running ; then  
	vagrant up --no-provision
	print_success
    else 
	printf "\nvirtual machine is already running..."
    fi
    printf "load Docker container..."
    # actually we don't need to load docker since docker 
    # run is super fast
    print_success
}

function clean() {
    printf "clean Virutalbox VM..."
#    vagrant destroy;
    print_success
    printf "clean Docker container..."
    docker rm -f pub sub;
    print_success
}

# Reset in case getopts has been used previously in the shell.
OPTIND=1
OPTIONS=$(getopt -o hbdrlct -l bootstrap,destroy,run,load,clean,terminate -- "$@")
[ $? != 0 ] && exit 1

eval set -- "$OPTIONS"

# echo "$OPTIONS"
# Print help message if no parameters
[ $# -eq 1 ] && help

is_start=0
# TODO: port detection algorithm 
unset ports
ports[0]=10000   # default info_port
ports[1]=1234     # default pub_port
ports[2]=1234     # default sub_port
while [ $# -gt 0 ]
do
    case "$1" in
     	-h | --help )
	    help;
	    exit ;;
     	-b | --bootstrap )
	    printf "boostrap infrastructure for the platform (hours long), are you sure? [N/y]"
	    bootstrap;
	    break ;;
     	-d | --destroy )
	    printf "destroy infrastructure for the platform...\n"
	    destroy;
	    break ;;
     	-r | --run )
	    printf "run test...\n";
	    run ${ports[@]};
	    break ;;
     	-l | --load )
	    printf "load the platform...\n";
	    shift 2;
	    for i in {0..2} 
	    do
		if [ $# -eq 0 ] ; then break; fi
		if ! [[ $1 =~ ^[0-9]+$ ]] ; then
		    fail "need a number as info_port"
		else
		    ports[$i]=$1;
		    shift
		fi	  
	    done;
	    # echo ${ports[@]};
	    load ${ports[@]};
	    break ;;
     	-c | --clean )
	    printf "clean the platform...\n"
	    clean;
	    break ;;
     	-t | --terminate )
	    printf "terminate the test...\n";
	    terminate;
	    break ;;
	-- ) shift ;;
	*)  fail "Internal error!";
	    break;;
    esac
done
