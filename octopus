# -*- mode: shell-script -*-
#!/bin/sh

# Help message
function help() {
    printf "Usage: octopus  [OPTIONS]\n"
    printf "Usage: octopus  [OPTIONS] [info_port] [pub_port] [sub_port]\n"
    printf "Run a distributed test (Mesenger) of OpenDDS\n"
    printf ""
    printf "Options:\n"
    printf "\t-h,  --help\t\tShow this message\n"
    printf "\t-b,  --bootstrap\tBootstrap the whole platform (build Docker Linux container and Vagrant box from scratch)\n"
    printf "\t-d,  --destroy\t\tdestroy the platform and remove Docker Linux container and Vagrant box\n"
    printf "\t-r,  --run\t\tRun the tests\n"
    printf "\t-s,  --start\t\tStart the platform\n"
    printf "\t-t,  --terminate\tTerminate the platform\n"
    printf ""
    printf "Example:\n"
    printf "\toctopus --start 10000 1234 1234\t Start the platform (info_port=10000, pub_port=1234, sub_port=1234)\n"
    printf "\toctopus --start\t Start the platform with default ports\n"
    printf "\toctopus --run \t Run the test (after start the platform)\n" 
   printf "\toctopus -h\n"
}

# utility function
print_success() {
    printf "\t: done\n"
}

error() {
  echo "$@" 1>&2
}

fail() {
  error "$@" && exit 1
}

function bootstrap() {
    ./check
    sudo docker rmi docker_opendds 
    printf "build Docker image...\n"
    # ./rebuild docker
    print_success
    printf "build Vagrant box...\n"
    vagrant box remove dds
    # ./rebuild vagrant
    print_success

    # Let linux kernel forward the packet
    printf "enable Linux kernel forwarding packets..."
    forward=$(cat /proc/sys/net/ipv4/ip_forward)
    if [ $forward -eq 0 ]; then
	sudo 'echo 1 > /proc/sys/net/ipv4/ip_forward' 
	print_success
    else
	fail "cannot let Linux kernel forwarding packets..."
    fi

    printf "check virtual box bridge..."
    vboxnet=$(ip addr show vboxnet0 > /dev/null)
    if [ $vboxnet -ne 0 ] ; then
	vboxmanage hostonlyif create
	print_success
    fi
}

function destroy() {
    terminate
    printf "clean Docker image...\n"
#    sudo docker rmi docker_opendds 
    print_success
    printf "clean Vagrant box...\n"
#    vagrant destroy
    print_success
}

function run() {

    printf "run inforepo..."
    sed -e "s/repo_port/$repo_port/g" \
	-e "s/repo_ip/$repo_ip/g" \
	-e "s/repo_gateway/$repo_gateway/g" \
	./scripts/run_dds_win_template.bat > ./scripts/run_dds_win.bat ;
    vagrant provision &
    
    # echo "wait a moment for inforepo starting..."
    sleep 30
    print_success
    
    printf "run publisher..."
    docker run \
	-d --name pub -v "$PWD/scripts:/scripts" -w /scripts --env "repo_port=$repo_port" \
	--env "repo_ip=$repo_ip"  --env "host_port=$host_port" \
	-p $host_port \
	opendds_update \
	/scripts/publisher.sh
    sleep 5
    print_success
    
    printf  "run subscriber..."
    docker run \
	-d --name sub -v "$PWD/scripts:/scripts" -w /scripts --env "repo_port=$repo_port" \
	--env "repo_ip=$repo_ip" --env "host_port=$host_port" \
	-p $host_port \
	opendds_update \
	/scripts/subscriber.sh
    print_success
}

function terminate() {
    printf "terminate Virtualbox VM..."
#    vagrant halt;
    print_success
    printf "terminate Docker container..."
#    docker stop;
    print_success
}

function load() {
    printf "load Vagrant box..."
    vm_name=repo_vm
    sed -e "s/repo_port/$repo_port/g" \
	-e "s/vm_name/$vm_name/g" \
	Vagrant_template > Vagrantfile

    if ! vagrant status | grep repo_vm | grep -q running ; then  
	vagrant up --no-provision
	print_success
    else 
	printf "\nvirtual machine is already running..."
    fi
    printf "load Docker container..."
    # actually we don't neet load docker since docker 
    # run is super fast
    print_success
}

function clean() {
    printf "clean Virutalbox VM..."
#    vagrant destroy;
    print_success
    printf "clean Docker container..."
    docker rm -f pub sub;
    print_success
}

# Reset in case getopts has been used previously in the shell.
OPTIND=1
OPTIONS=$(getopt -o hbdrlct -l bootstrap,destroy,run,load,clean,terminate -- "$@")
[ $? != 0 ] && exit 1

eval set -- "$OPTIONS"

# echo "$OPTIONS"
# Print help message if no parameters
[ $# -eq 1 ] && help

is_start=0
# TODO: port detection algorithm 
unset ports
ports[0]=10000   # default info_port
ports[1]=1234     # default pub_port
ports[2]=1234     # default sub_port
while [ $# -gt 0 ]
do
    case "$1" in
     	-h | --help )
	    help;
	    exit ;;
     	-b | --bootstrap )
	    printf "boostrap infrastructure for the platform (hours long), are you sure? [N/y]"
	    bootstrap;
	    break ;;
     	-d | --destroy )
	    printf "destroy infrastructure for the platform...\n"
	    destroy;
	    break ;;
     	-r | --run )
	    printf "run test...\n";
	    run;
	    break ;;
     	-l | --load )
	    printf "load the platform...\n";
	    shift 2;
	    for i in {0..2} 
	    do
		if [ $# -eq 0 ] ; then break; fi
		if ! [[ $1 =~ ^[0-9]+$ ]] ; then
		    fail "need a number as info_port"
		else
		    ports[$i]=$1;
		    shift
		fi	  
	    done;
	    # echo ${ports[@]};
	    load ${ports[@]};
	    break ;;
     	-c | --clean )
	    printf "clean the platform...\n"
	    clean;
	    break ;;
     	-t | --terminate )
	    printf "terminate the test...\n";
	    terminate;
	    break ;;
	-- ) shift ;;
	*)  fail "Internal error!";
	    break;;
    esac
done
